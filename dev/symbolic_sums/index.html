<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Symbolic Sums and Indices · QuantumCumulants.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">QuantumCumulants.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><a class="tocitem" href="../theory/">Theoretical background</a></li><li><a class="tocitem" href="../tutorial/">Tutorial</a></li><li><a class="tocitem" href="../correlation/">Correlation functions and spectra</a></li><li><a class="tocitem" href="../implementation/">Implementation</a></li><li><a class="tocitem" href="../api/">API</a></li><li class="is-active"><a class="tocitem" href>Symbolic Sums and Indices</a><ul class="internal"><li><a class="tocitem" href="#Implementation"><span>Implementation</span></a></li><li><a class="tocitem" href="#Short-Example"><span>Short Example</span></a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../examples/single-atom-laser-spectrum/">Spectrum of a single-atom laser</a></li><li><a class="tocitem" href="../examples/mollow/">Mollow Triplet</a></li><li><a class="tocitem" href="../examples/many-atom-laser/">Many-atom laser</a></li><li><a class="tocitem" href="../examples/optomechanical-cooling/">Optomechanical Cooling</a></li><li><a class="tocitem" href="../examples/excitation-transport-chain/">Noisy excitation transport</a></li><li><a class="tocitem" href="../examples/ramsey_spectroscopy/">Ramsey Spectroscopy</a></li><li><a class="tocitem" href="../examples/superradiant_laser_indexed/">Superradiant Laser</a></li><li><a class="tocitem" href="../examples/cavity_antiresonance_indexed/">Cavity Antiresonance</a></li><li><a class="tocitem" href="../examples/filter-cavity_indexed/">Laser with Filter Cavities</a></li><li><a class="tocitem" href="../examples/superradiant-laser/">Superradiant Laser (outdated)</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Symbolic Sums and Indices</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Symbolic Sums and Indices</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/qojulia/QuantumCumulants.jl/blob/master/docs/src/symbolic_sums.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Symbolic-Sums-and-Indices"><a class="docs-heading-anchor" href="#Symbolic-Sums-and-Indices">Symbolic Sums and Indices</a><a id="Symbolic-Sums-and-Indices-1"></a><a class="docs-heading-anchor-permalink" href="#Symbolic-Sums-and-Indices" title="Permalink"></a></h1><p>Many physical systems contain multiple elements of the same kind, which basically do the same thing just with different rates. For these systems it is convenient to describe the Hamiltonian and the dissipative processes with indexed objects and sums. A well-known example is the Tavis-Cummings Hamiltonian, which describes the interaction of <span>$N$</span> two-level atoms with a cavity mode according to the Hamiltonian</p><p class="math-container">\[\begin{equation}
H_\mathrm{TC} = \omega_c a^† a + \sum_i^N \omega_i \sigma_i^{22} + \sum_i^N g_i (a^\dagger \sigma_i^{12} + a \sigma_i^{21}).
\end{equation}\]</p><p>In principle we can write down and derive the equations for all <span>$N$</span> atoms explicitly, but this can take a long time for large <span>$N$</span>. The more practical and elegant approach is to derive the equations for averages of indexed operators and insert all possible number combinations afterwards. The implementation of symbolic sums and indices allows for exactly this.</p><h2 id="Implementation"><a class="docs-heading-anchor" href="#Implementation">Implementation</a><a id="Implementation-1"></a><a class="docs-heading-anchor-permalink" href="#Implementation" title="Permalink"></a></h2><h3 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h3><p>The main tool to use symbolic summations is the <strong>Index</strong> object. This object has four different fields, which all need to be specified upon construction. These fields consist of the full <a href="../api/#QuantumCumulants.HilbertSpace"><code>HilbertSpace</code></a> <strong>h</strong>, a <strong>name</strong>, which is just a generic symbol, a <strong>range</strong>, which can either consist of again a symbol or a concrete number and a specific Hilbert space <strong>aon</strong>, which defines the space on which operators, that inherit the <strong>Index</strong> entity, act on. This means that an <strong>Index</strong>, for a <a href="../api/#QuantumCumulants.NLevelSpace"><code>NLevelSpace</code></a> can only be used by <a href="../api/#QuantumCumulants.Transition"><code>Transition</code></a> operators. In the example below, two indices are defined equivalently, as well as a third one being defined acting on the <a href="../api/#QuantumCumulants.FockSpace"><code>FockSpace</code></a> of the defined <a href="../api/#QuantumCumulants.ProductSpace"><code>ProductSpace</code></a> <strong>h</strong>.</p><pre><code class="language-julia">using QuantumCumulants

@cnumbers N

ha = NLevelSpace(:atoms,2)
hc = FockSpace(:cavity)
h = hc ⊗ ha

i = Index(h,:i,N,ha)
i2 = Index(h,:i,N,2) #equivalent definition

n = Index(h,:n,5,hc)</code></pre><pre class="documenter-example-output">Index(ℋ(cavity) ⊗ ℋ(atoms), :n, 5, 1)</pre><h3 id="IndexedOperators"><a class="docs-heading-anchor" href="#IndexedOperators">IndexedOperators</a><a id="IndexedOperators-1"></a><a class="docs-heading-anchor-permalink" href="#IndexedOperators" title="Permalink"></a></h3><p>Operators, such as the quantum harmonic destruction operator <a href="../api/#QuantumCumulants.Destroy"><code>Destroy</code></a> or the <a href="../api/#QuantumCumulants.Transition"><code>Transition</code></a> operator can be associated with an <a href="../api/#QuantumCumulants.Index"><code>Index</code></a> of the corresponding Hilbert space by creating a so called <a href="../api/#QuantumCumulants.IndexedOperator"><code>IndexedOperator</code></a>. This object consists of two fields, namely the operator itself and an <strong>Index</strong>. Below, there are two <strong>IndexedOperator</strong> entities created on the two different Hilbert spaces defined previously.</p><pre><code class="language-julia">σ(x,y,z) = IndexedOperator(Transition(h,:σ,x,y),z)
a(z) = IndexedOperator(Destroy(h,:a),z)</code></pre><pre class="documenter-example-output">a (generic function with 1 method)</pre><p>In the above example, we defined both indexed operators <strong>σ</strong> and <strong>a</strong> as callable Instances with the attribute-variable <strong>z</strong>. These can now be used to easily create operators, that act specifically with their associated index.</p><pre><code class="language-julia">a(n)*σ(2,2,i)</code></pre><p class="math-container">\[{a}_{n} {\sigma}_{i}^{{22}}\]</p><p>Similar to operators, one can also create so called <a href="../api/#QuantumCumulants.IndexedVariable"><code>IndexedVariable</code></a> objects, which consist simply of a name and an index.</p><pre><code class="language-julia">gi = IndexedVariable(:g,i)</code></pre><p class="math-container">\[{g}_{i}\]</p><h3 id="Summations"><a class="docs-heading-anchor" href="#Summations">Summations</a><a id="Summations-1"></a><a class="docs-heading-anchor-permalink" href="#Summations" title="Permalink"></a></h3><p>As for now, we only created single instances of indexed operators. These operators and variables can now be used to define symbolic summations, which can then again be used in defining a Hamiltonian and deriving equations of motion for specific operator averages. Such a summation needs two arguments to be constructed, the <strong>term</strong>, over which the summation shall sum over, and an <a href="../api/#QuantumCumulants.Index"><code>Index</code></a>, over which the sum runs. As an example, we define below a simple sum over a single indexed operator.</p><pre><code class="language-julia">∑(σ(2,2,i),i)</code></pre><p class="math-container">\[\underset{i}{\overset{N}{\sum}} {σ}_{i}^{{22}}\]</p><p>As can be seen above, a sum with a single running-index can be created using the <strong>∑</strong> (\sum) command. Other equivalent functions are <strong>Σ</strong> (\Sigma) and the <strong>SingleSum()</strong> constructor. These constructors can also take a third optional argument specifying a set of indices, which are non equivalent to the summation index. </p><pre><code class="language-julia">j = Index(h,:j,N,2)
∑(σ(2,2,i),i,[j])</code></pre><p class="math-container">\[\underset{i ≠j }{\overset{N}{\sum}} {σ}_{i}^{{22}}\]</p><p>Similar to this one can also create summations over up to two different running-indices:</p><pre><code class="language-julia">∑(a(n)*σ(2,1,i),i,n)</code></pre><p class="math-container">\[\underset{i}{\overset{N}{\sum}} \underset{n}{\overset{5}{\sum}} {a}_{n}  {σ}_{i}^{{21}}\]</p><p>These two running-indices do not need to act on different Hilbert spaces. However, for indices acting on the same Hilbert space, a simplification occurs, as shown below.</p><pre><code class="language-julia">k = Index(h,:k,N,ha)
l = Index(h,:l,N,ha)

∑(σ(2,1,k)*σ(1,2,l),k,l)</code></pre><p class="math-container">\[\underset{k{\ne}l}{\overset{N}{\sum}} \underset{l{\ne}k}{\overset{N}{\sum}} {\sigma}_{l}^{{12}}  {\sigma}_{k}^{{21}} + \underset{k}{\overset{N}{\sum}} {\sigma}_{k}^{{22}}\]</p><p>If two indices, acting on the same Hilbert space, meet inside of a sum, the special case, where the numeric values of both indices are the same, i.e <code>l</code>=<code>k</code>, is calculated immediately. This can also be observed, when a symbolic sum is multiplied with an <a href="../api/#QuantumCumulants.IndexedOperator"><code>IndexedOperator</code></a>, that is acting on the same Hilbert space as the summation-index.</p><pre><code class="language-julia">∑(σ(2,2,k),k) * σ(2,1,l)</code></pre><p class="math-container">\[\underset{k{\ne}l}{\overset{N}{\sum}} {\sigma}_{k}^{{22}}  {\sigma}_{l}^{{21}} + {\sigma}_{l}^{{21}}\]</p><h2 id="Short-Example"><a class="docs-heading-anchor" href="#Short-Example">Short Example</a><a id="Short-Example-1"></a><a class="docs-heading-anchor-permalink" href="#Short-Example" title="Permalink"></a></h2><p>We will briefly go over the entire process of defining a Hamiltonian, the derivation of equations and solving these equations numerically. For this example we will consider <strong>N</strong> 2-level atoms in a single mode Cavity.</p><p>We start by defining all indices and operators and create the Hamiltonian.</p><pre><code class="language-julia">using QuantumCumulants

ha = NLevelSpace(:atoms,2)
hc = FockSpace(:cavity)
h = hc ⊗ ha

@cnumbers N Δ κ γ ν

i = Index(h,:i,N,ha)
j = Index(h,:j,N,ha)

@qnumbers b::Destroy(h)
σ(x,y,z) = IndexedOperator(Transition(h,:σ,x,y),z)
gi = IndexedVariable(:g,i)

H = Δ*b&#39;*b + ∑(gi*(b*σ(2,1,i) + b&#39;*σ(1,2,i)),i)</code></pre><p class="math-container">\[\underset{i}{\overset{N}{\sum}} {g}_{i}  b  {\sigma}_{i}^{{21}} + \underset{i}{\overset{N}{\sum}} {g}_{i}  b^\dagger  {\sigma}_{i}^{{12}} + \Delta b^\dagger b\]</p><p>We continue by defining the starting operators <strong>ops</strong>, for which the equations are calculated, as well as the Jump operators <strong>J</strong> with their corresponding rates. It is important to note here, that the indexed operators, for which these equations are calculated need to have an <a href="../api/#QuantumCumulants.Index"><code>Index</code></a>, which is not yet used in the Hamiltonian, jumps or rates. We can then create the first set by simply calling the <strong>meanfield</strong> function.  Note that if an indexed operator <span>$J_i$</span> is used as jump operator, the following dissipative term is created </p><p class="math-container">\[\begin{equation}
\frac{1}{2} \sum_{j} R_{i} \bigg( 2 J_i^\dagger \mathcal{O} J_i - \mathcal{O} J_i^\dagger J_i -  J_i^\dagger J_i \mathcal{O} \bigg).
\end{equation}\]</p><p>The corresponding rate can, but does need to be an indexed variable. However, if it is, then the index of variable needs to match with the operator.</p><pre><code class="language-julia">ops = [b&#39;b, σ(2,2,j)]
J = [b, σ(1,2,i), σ(2,1,i)]
rates = [κ, γ, ν]

eqs = meanfield(ops,H,J;rates=rates,order=2)</code></pre><p class="math-container">\[\begin{align}
\frac{d}{dt} \langle b^\dagger  b\rangle  =&amp; 1 i \underset{i}{\overset{N}{\sum}} {g}_{i}  \langle b  {\sigma}_{i}^{{21}}\rangle  -1 i \underset{i}{\overset{N}{\sum}} {g}_{i}  \langle b^\dagger  {\sigma}_{i}^{{12}}\rangle  -1.0 \kappa \langle b^\dagger  b\rangle  \\
\frac{d}{dt} \langle {\sigma}_{j}^{{22}}\rangle  =&amp; \nu + 1 i {g}_{j} \langle b^\dagger  {\sigma}_{j}^{{12}}\rangle  -1.0 \gamma \langle {\sigma}_{j}^{{22}}\rangle  -1.0 \nu \langle {\sigma}_{j}^{{22}}\rangle  -1 i {g}_{j} \langle b  {\sigma}_{j}^{{21}}\rangle 
\end{align}\]</p><p>We can then complete the set of equations by simply calling the <strong>complete</strong> function.</p><pre><code class="language-julia">eqs_comp = complete(eqs)</code></pre><h3 id="Evaluate-and-Scale"><a class="docs-heading-anchor" href="#Evaluate-and-Scale">Evaluate and Scale</a><a id="Evaluate-and-Scale-1"></a><a class="docs-heading-anchor-permalink" href="#Evaluate-and-Scale" title="Permalink"></a></h3><p>The equations still contain symbolic summations and indices. Until now, we did not specify a numerical value for the upper boundaries of the summations, meaning the used <strong>N</strong> still has no numerical assignment. There are now two different cases to create the set of equations with a specific number of elements. We can either construct all equations for <strong>N</strong> individual atoms with the function <a href="../api/#QuantumCumulants.evaluate"><code>evaluate</code></a> or we assume that all particles behave identical and create the equations with the function <a href="../api/#QuantumCumulants.scale"><code>scale</code></a>. The latter uses the symmetry properties of identical particles, which can substantially reduce the number of equations. </p><p>In this example we use <strong>evaluate</strong> for <span>$N=3$</span> atoms. We can specify the numerical value of <span>$N$</span> to 3 within the kwarg <code>limits</code>.</p><pre><code class="language-julia">evaled = evaluate(eqs_comp;limits=(N=&gt;3))</code></pre><p>The last set of equations are now in a numerical solvable form, that we can convert to an <code>ODESystem</code> as defined in <a href="https://github.com/SciML/ModelingToolkit.jl">ModelingToolkit</a>, which can be solved numerically with <a href="https://github.com/JuliaDiffEq/OrdinaryDiffEq.jl">OrdinaryDiffEq</a>. Furthermore we give each atom a different coupling strength <code>g</code>. This can now be done by using the <a href="../api/#QuantumCumulants.value_map"><code>value_map</code></a> function to create a parameter mapping for the <code>ODEProblem</code>. In this case we give as coupling strength a vector with three different values.</p><pre><code class="language-julia"># Generate an ODESystem
using ModelingToolkit
@named sys = ODESystem(evaled)

# Solve the system using the OrdinaryDiffEq package
using OrdinaryDiffEq
u0 = zeros(ComplexF64,length(evaled))
p = [Δ, gi, γ, κ, ν]
p0 = [0,[0.75,1.2,1.5],0.25,1,1.5]
p_ = value_map(p,p0;limits=(N=&gt;3))
prob = ODEProblem(sys,u0,(0.0,10.0),p_)
sol = solve(prob,RK4())</code></pre><pre class="documenter-example-output">WARNING: using ModelingToolkit.complete in module ex-symbolic_sums conflicts with an existing identifier.</pre><p>Just as with variables in <a href="https://github.com/SciML/ModelingToolkit.jl">ModelingToolkit</a>, the solution of the respective averages can be accessed with a <code>getindex</code> method. In the following we extract and plot the photon number and the atomic excited state population of each atom by indexing the solution:</p><pre><code class="language-julia">using Plots
n = real.(sol[b&#39;*b])
pe = [real.(sol[σ(2,2,i)]) for i = 1:3]
pl = plot(sol.t, n, label=&quot;Photon number&quot;, xlabel=&quot;t&quot;)
for i = 1:3
    plot!(sol.t, pe[i], label=&quot;Excited state population of atom $(i)&quot;)
end</code></pre><pre class="documenter-example-output">&quot;/home/runner/work/QuantumCumulants.jl/QuantumCumulants.jl/docs/build/symbolic_sums.svg&quot;</pre><p><img src="../symbolic_sums.svg" alt="Photon number and excited state population"/></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../api/">« API</a><a class="docs-footer-nextpage" href="../examples/single-atom-laser-spectrum/">Spectrum of a single-atom laser »</a><div class="flexbox-break"></div><p class="footer-message"><a href="https://github.com/qojulia/QuantumCumulants.jl"><strong>Back to GitHub</strong></a></p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 2 December 2022 19:10">Friday 2 December 2022</span>. Using Julia version 1.8.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
